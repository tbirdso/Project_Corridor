using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

namespace MapTiling {
    
    //Translate output from the AssembleNET program into Tile properties in Unity
    public class TileOutputReader : MonoBehaviour
    {
        #region Constants
        // Number of expected fields in one CSV record
        const int NUM_TILE_FIELDS = 9;
        const int NUM_MULTI_FIELDS = 6;
        #endregion

        #region Public Members
        // Default prefab to instantiate tiles backfilled by AssembleNET engine
        public Tile BackfillPrefab;
        #endregion

        #region Public Methods
        /* Read output from CSV text channel into Tile properties in Unity
         * Arguments:   file: absolute path to .csv file with AssembleNET engine output
         *              tiles:  Unity list of Tile instances in the scene
         */
        public void ReadFromFile(string file, List<Tile> tiles)
        {
            string line = null;
            Tile match = null, adj = null;
            string id = null;

            using (StreamReader reader = new StreamReader(file))
            {
                while(!reader.EndOfStream)
                {
                    // Format: tile,[id],[x],[z],[rotations],[N-adjacency],[S-adjacency],[E-adjacency],[W-adjacency]
                    // Sample line:
                    // tile,backfill-N-gen2,0,2,0,nil,Tile4,nil,nil
                    if ((line = reader.ReadLine()).StartsWith("tile"))
                    {
                        String[] fields = line.Split(',');
                        Debug.Assert(fields.Length == NUM_TILE_FIELDS, 
                            "Expected " + NUM_TILE_FIELDS + " fields in line, found " + fields.Length);

                        id = fields[1];
                        if (!id.Contains("backfill"))
                        {
                            match = tiles.Find(t => t.name.Equals(id));
                            if(match != null)
                                match.rotations = int.Parse(fields[4]);

                        } else
                        {
                            //"backfill" tiles were generated by the assembler and must be instantiated
                            match = Instantiate(BackfillPrefab);
                            match.name = id;
                            tiles.Add(match);

                            if(id.Contains("backfill-N"))
                            {
                                match.rotations = 2;
                            } else if(id.Contains("backfill-E"))
                            {
                                match.rotations = 3;
                            } else if(id.Contains("backfill-S"))
                            {
                                match.rotations = 0;
                            } else if(id.Contains("backfill-W"))
                            {
                                match.rotations = 1;
                            } else
                            {
                                match.rotations = 0;
                            }
                        }

                        // If the tile is instantiated in the scene set its properties
                        if (match != null)
                        {
                            match.coordinates.x = int.Parse(fields[2]);
                            match.coordinates.y = int.Parse(fields[3]);

                            foreach (CardinalDirection c in Enum.GetValues(typeof(CardinalDirection)))
                            {
                                adj = (fields[5 + (int)c].Equals("nil")) ? null : tiles.Find(t => t.name.Equals(fields[5 + (int)c]));
                                match.EdgeAdjacency[c] = adj;
                            }

                            match.assembled = true;
                        }
                        else
                        {
                            // Multitile component tiles should be skipped
                            continue;
                        }
                    }

                    // Format: multitile,[id],[x_min],[x_max],[z_min],[z_max]
                    // Sample line:
                    // multitile,Wide,-3,-2,1,1
                    else if (line.StartsWith("multitile"))
                    {
                        String[] fields = line.Split(',');

                        id = fields[1];

                        // Find the multitile in the scene
                        match = tiles.Find(t => t.name.Equals(id));
                        if (match != null && fields.Length == NUM_MULTI_FIELDS)
                        {
                            match.coordinates.x = (float)(int.Parse(fields[2]) + int.Parse(fields[3])) / 2;
                            match.coordinates.y = (float)(int.Parse(fields[4]) + int.Parse(fields[5])) / 2;
                            match.assembled = true;
                        }
                    }
                }
            }
            
        }
        #endregion
    }
}